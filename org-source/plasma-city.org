#+PROPERTY: header-args :session plasma :export both :tangle yes
#+COLUMNS: %25ITEM %header-args

* Intro

** Foreword
My aim with this programm is to build a blog on which I can publish my  works.

** State of the coder
I already have a server running with python and mysql. I also have a domain name at ‘www.plasma.city’.
I already have good notions of programming with python and basic understanding of the web, html and css.

What I don't know though, is how to use the Flask micro-framework to build a website and deploy it on my server.
Also I don't know how I can export org files to html pages of website.
I would also like to add a script that publishes automaticly my articles based on a synchronisation of a folder on my local computer where I would save them.

** Purpose
So the aim of this programm is to provide an easy way to publish my work on a website. This website has to be an excellent communication tool presenting my work in a fancy way.

* Install instruction for this litterate programm

** What is litterate programming ?
Litterate programming is a programming method that emphasises the human reflexion over the computer understanding of your code.
Hence litterate programming is know for making programms more understandable for both programmers and non-programmers.
Literrate programming also has the virtue to make the documentation and design of the programm saner because it focuses on the end result and its publication.

This is my first attemt to write a program in litterate programming fashion.

** Org babel
All the code was writen in an org file. Org files can be opened in Emacs using a built-in mode called org-mode. It provides a convinient way to manage a litterate programm. In org files, code is cotained in code block which are organised in org headings. These heading can have meta-data so that we can use meta-programming to manage our code automaticly.

** Export Org File
You can download the org file and run it in emacs. Once you are in emacs org-mode visiting the file in a buffer, you can export the code contained in this org file to a full python module. This action is called tangling in litterate programming.


** Other exports
For compatibility with other work environements, I also exported the org files as a python package and as a jupyter notebook. You can also generate those easily by downloading the org file and exporting it in org-mode.

*** TODO How to export this org file to a python package ?

*** TODO How to export this org file to a jupyter notebook ?

* Code
** Overview

We will now write the code of our blog-website.

There are several way of designing a programm, here are two approches.

*** traditionnal programming perspective

 So, what code will wee need ?

**** python flask app

We will need a flask app to run our server. In this we will define how we handle queries made to our server. The server will for each query send back a different output that the client will load. OFr exemple if the client is visiting the website with a webbrowser, he will send http queries and we usually want to send him html documents back.

**** html documents

We need to build our skelton page. We can decide what shape the site has tp have, what parts will remain between each page, and what html code is specific to particular pages.

***** templates

We will handle the generalization of page structures with templates. This will be handled by a module that is implemented in flask called ninjasomething.

The aim is to be able to call templates and fill them depending on context.

***** css

The generalization of page apparences will be generated by our css files.


*** litterate programming perspective

So, what do we need ?

**** layers

We need to let different layers communicate together to act as a system that matches our desires

***** server program

First we want the server to deliver the our website to visitor. In html first.

***** server data

The server needs to acces the data he has to retrive.

***** filling the server

We need to populate the server with local data.

** Let's get started
:PROPERTIES:
:HEADER-ARGS: :session flask-app :export both :tangle ../application/flaskapp.py
:END:
 We will choose the litterate programming perspective.
 So we need to build a server able to retrive html, based on available data that we feed him with.
*** Server
**** Flask Application

When we run the app, we would like to be able to access it with a browser. Let's make our server alive and talking.

This is this can be considered as an introduction to flask. It follows the flask quickstart page.

To understand how this link is managed in our final file tangling (when all the file is exported as a whole programm ready to run) please sea [[*Follow links][Org Tangle Appendice]]. You can refer to the appendice each time there is a special meta-programming code doing things you don't understand.

An easy way to go back and forth is to use the command C-u C-SPC to come back to the place you where before visiting the link or doing a isearch or chatever other command you used to make you jump to another position. This is a very handy tool for quick navigation. You can now jump headlessly around, you have a way to come back !

***** imports
#+BEGIN_SRC python
    from flask import Flask
    from flask import render_template
#+END_SRC

#+RESULTS:

***** app definition
#+BEGIN_SRC python
    app = Flask(__name__)
#+END_SRC
***** COMMENT route

The route() function binds a function to an URL

#+BEGIN_SRC python
    @app.route('/')
    def index():
        return 'Index Page'
#+END_SRC

#+RESULTS:

***** COMMENT rules variables

You can add variable sections to a URL by marking sections with <variable_name>. Your function then receives the
<variable_name> as a keyword argument.

Optionally, you can use a converter to specify the type of the argument like
<converter:variable_name>

#+BEGIN_SRC python
@app.route('/user/<username>')
def show_user_profile(username):
    # show the user profile for that user
    return 'User %s' % username

@app.route('/post/<int:post_id>')
def show_post(post_id):
    # show the post with the given id, the id is an integer
    return 'Post %d' % post_id

@app.route('/path/<path:subpath>')
def show_subpath(subpath):
    # show the subpath after /path/
    return 'Subpath %s' % subpath
#+END_SRC

#+RESULTS:

***** COMMENT URL building

#+BEGIN_SRC python

    from flask import url_for

    @app.route('/login')
    def login():
        return 'login'

    @app.route('/usr/<username>')
    def profile(username):
        return '{}\'s profile'.format(username)

    with app.test_request_context():
        print(url_for('index'))
        print(url_for('login'))
        print(url_for('login', next='/'))
        print(url_for('profile', username='John Doe'))

#+END_SRC

#+RESULTS:

***** COMMENT rendering templates

#+BEGIN_SRC python

    @app.route('/plasma-city/')
    def plasma_city():
        return render_template('plasma-city.html')

#+END_SRC

**** Server Deployment

Now the server works localy, let's try to put it on my distant server.

We will use the instructions of Gandi for deployment.

Git is the standard way.

Refer to Gandi page for details

*** Content
So now our server can send data that can be viewed in a browser.
What do we now want the visitor to sea ? Obviously our articles. Maybe a mainpage containg all articles. Maybe a side bar. All this can be generated by templates.
**** templates architecture and content

These are the requirements :

***** base

****** footer

******* author

******* credit

******* emacs

******* modification date

****** list of articles

****** menu

***** start page

****** welcome message

****** presentation

****** links

***** article page

****** integrated in the base

***** menu

****** 1

******* Art

******* DS

******* Computing

****** 2

******* Contact

******* A propos
**** Publishing : Html pages generation with org export
***** how to make links relevant and generated automaticly ?
:LOGBOOK:
CLOCK: [2018-09-01 sam. 17:52]
:END:
****** org export implemented link management between org files
https://www.gnu.org/software/emacs/manual/html_node/org/Publishing.html
https://orgmode.org/worg/org-tutorials/org-publish-html-tutorial.html
******* Jinja compatible ?
******** PB: Doesn't take jinja's template system into account
******** Sol: Implement it.
********* Configure exports to fit into jinja's file system & export specifications to match jinja language
******** Use it without jinja first ?
********* yes
********* DONE create a static file html pages system
CLOSED: [2018-09-01 sam. 21:46]
********* serve the first page with flask and hope links work
#+BEGIN_SRC python

    @app.route('/')
    def front():
        return render_template('homepage.html')

#+END_SRC
********** DONE Add a homepage with link to the static files
CLOSED: [2018-09-02 dim. 16:53]
:LOGBOOK:
- State "DONE"       from              [2018-09-02 dim. 16:53] \\
  Using static template and path to hack around
:END:
Hacky and shaky
********** CANCELED change the way org publish refers links wetween html files ?
CLOSED: [2018-09-02 dim. 17:16]
:LOGBOOK:
- State "CANCELED"   from              [2018-09-02 dim. 17:16] \\
  Better create a little script in lisp or python beside.
:END:
********** publish in templates and create a script to jinjaify it afterwards
***** articles / pages
****** export html files for each project in this templates directory ?
****** treat each html file separatly ?
****** work with a more modular system using js/DOM ?
*** TODO Optimization
**** home page
***** automatize generation of links to the articles
***** make pretty
**** articles
***** put a link to the home page when publishing
**** TODO use templates
We now have to learn about Flask's sidekick : jinja.
We could use it to build links between template pages.
**** TODO css ?
***** TODO relationship with org mode ?
* Appendices

** Org Tangle

*** General

We will need to be able to tangle the code in this org file to the expected files. Why not even have the html code contained in this file so that everything is accessible on a signle page ?
For this to work the way we want, we need to make sure that in the tangling process, each source code block is exported so that the outcome is a nice organised directory. This can be done by defining properties to source block header and defining rules that will tangle deferent properties differently.

*** Follow links
We did not wanted to separate the code in different files. But it could have been done so for convinience. But since the org file view is modulable, why would we need to ?

There is such a possibility though, that the tangling process follows links and do some specific action on the encountered file. It can be very powerfull in other context.

To figure this out, one should check John Kitchin's work on his blog and github page.

*** Tangle according to the file system

We want org to tangle the different code blocks in this file in specific locations in our project directory. This can be done by adding to the "header-args" property the value ":tangle "path/to/our/file/directory/file-name.file-extension" "

Note that we need to specify an extension because we are not givin the value "yes" to :tangle, so the tangling process awaits from us that we specify path, file name and extension.
*** Tangle all code blocks in a subtree to the same file
In order to do this, we need to add a property to the headline whose children we want to have the same output file. To set a property C-c C-x p can help. Now we define a header-args property with value ":tangle path/to/our/file/file-name.filext"

In order to make this work, we need to able properties inheritance and add the property header-args to the list of inheretable properties.
